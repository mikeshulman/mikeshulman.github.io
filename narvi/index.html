<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Narvi</title>
    <link rel="stylesheet" href="styles.css">
    <script src=" https://cdn.jsdelivr.net/npm/interactjs@1.10.27/dist/interact.min.js "></script>
    <script src="narvi.bc.js"></script>
</head>
<body>
    <div id="palette">
        <div class="basic intro rule" id="andI" data-rule="andI">‚àß</div>
        <div class="basic elim rule" id="andE" data-rule="andE">‚àß</div>
        <div class="basic intro rule" id="orI1" data-rule="orI1">‚à®<sub>L</sub></div>
        <div class="basic intro rule" id="orI2" data-rule="orI2">‚à®<sub>R</sub></div>
        <div class="container rule" id="orE" data-rule="orE">
          <div class="mid bar"></div>
          <div class="doubleleft assumption"><div class="subgoallabel">‚à®</div></div>
          <div class="doubleright subgoal"></div>
          <div class="mid midleft"></div>
          <div class="mid midright"></div>
        </div>
        <div class="container rule" id="impI" data-rule="impI">
          <div class="bottom bar"></div>
          <div class="singleleft assumption"></div>
          <div class="singleright subgoal"><div class="subgoallabel">‚áí</div></div>
          <div class="bottomleft"></div>
          <div class="bottomright"></div>
        </div>
        <div class="basic elim rule" id="impE" data-rule="impE">‚áí</div>
        <div class="container rule" id="iffI" data-rule="iffI">
          <div class="mid bar"></div>
          <div class="doubleleft assumption"></div>
          <div class="doubleright subgoal"><div class="subgoallabel">‚áî</div></div>
          <div class="mid midleft"></div>
          <div class="mid midright"></div>
        </div>
        <div class="basic elim rule" id="iffE1" data-rule="iffE1">‚áî<sub>L‚ÜíR</sub></div>
        <div class="basic elim rule" id="iffE2" data-rule="iffE2">‚áî<sub>R‚ÜíL</sub></div>
        <div class="basic intro rule" id="exI" data-rule="exI"> ‚àÉ</div>
        <div class="basic elim rule" id="exE" data-rule="exE">‚àÉ</div>
        <div class="container rule" id="allI" data-rule="allI">
          <div class="bottom bar"></div>
          <div class="singleleft assumption"></div>
          <div class="singleright subgoal"><div class="subgoallabel">‚àÄ</div></div>
          <div class="bottomleft"></div>
          <div class="bottomright"></div>
        </div>
        <div class="basic elim rule" id="allE" data-rule="allE">‚àÄ</div>
        <div class="basic elim rule" id="negE" data-rule="negE">¬¨</div>
        <div class="container rule" id="negI" data-rule="negI">
          <div class="bottom bar"></div>
          <div class="singleleft assumption"></div>
          <div class="singleright subgoal"><div class="subgoallabel">¬¨</div></div>
          <div class="bottomleft"></div>
          <div class="bottomright"></div>
        </div>
        <div class="container rule" id="negnegI" data-rule="negnegI">
          <div class="bottom bar"></div>
          <div class="singleleft assumption" style="width:27px"><div class="assumptionlabel">¬¨</div></div>
          <div class="singleright subgoal"></div>
          <div class="bottomleft"></div>
          <div class="bottomright"></div>
        </div>
        <div class="basic rule" style="text-align: left" id="botE" data-rule="botE">‚ä•</div>
        <div class="basic rule" style="text-align: right" id="topI" data-rule="topI">‚ä§</div>
        <!-- <div class="basic rule" style="text-align: center" id="asc" data-rule="asc">üè∑</div> -->
        <div style="position: absolute; bottom: 10px" id="buttons"><button id="selectLevel">Select Level</button></div>
    </div>
    <div id="diagram"></div>

    <div id="currentLevel"></div>

    <div id="levelChooseBG" class="modalbg">
      <div class="modal" id="levelChooseModal">
        <div style="text-align: center; font-size: 24px; display: grid; grid-template-columns: 1fr 20px 500px 20px 1fr; margin-bottom: 20px">
          <div></div>
          <div id="backWorld" style="cursor: pointer">‚óÄ</div>
          <div id="worldName">Select a level</div>
          <div id="forwardWorld" style="cursor: pointer">‚ñ∂</div>
          <div></div>
        </div>
        <p id="chooseLevelWarning" style="display: none; text-align: center">(Choosing a new level clears any existing proof)</p>
        <div id="worlds">
        </div>
        <div style="text-align: center; margin-top: 30px">
          <input name="difficulty" type="radio" value="0" checked="1"> Novice &nbsp;&nbsp;
          <input name="difficulty" type="radio" value="1"> Adept &nbsp;&nbsp;
          <input name="difficulty" type="radio" value="2"> Expert &nbsp;&nbsp;
          <input name="difficulty" type="radio" value="3"> Master
        </div>
        <div style="text-align: center; margin-top: 30px">
          <button id="cancelChooseLevel" style="font-size: 16px; display: none">Cancel</button>
          <button id="clearHistory" style="font-size: 16px">Clear History</button>
          <button id="about" style="font-size: 16px">About</button>
          <br/>
        </div>
      </div>
    </div>

    <div id="levelSelectBG" class="modalbg">
      <div class="modal">
        <h3 style="text-align: center">What do you want to prove?</h3>
        <span id="setLevelWarning" style="display: none">(Choosing a new level clears any existing proof)</span>
        <p>Parameters, as <tt>name : type</tt>, one per line:</p>
        <textarea id="parameters" style="width: 100%" rows="3"></textarea>
        <div id="paramPalette"></div>
        <p>Variables, as <tt>name : type</tt>, one per line:</p>
        <textarea id="variables" style="width: 100%" rows="3"></textarea>
        <div id="varPalette"></div>
        <p>Hypotheses, types only (i.e. propositions), one per line:</p>
        <textarea id="hypotheses" style="width: 100%" rows="3"></textarea>
        <div id="hypPalette"></div>
        <p>Conclusion:</p>
        <input type="text" id="conclusion" style="width: 100%; font-family: monospace"/>
        <div id="conclPalette"></div>
        <div style="text-align: center; margin-top: 30px">
          <input name="customDifficulty" type="radio" value="0" checked="1"> Novice &nbsp;&nbsp;
          <input name="customDifficulty" type="radio" value="1"> Adept &nbsp;&nbsp;
          <input name="customDifficulty" type="radio" value="2"> Expert &nbsp;&nbsp;
          <input name="customDifficulty" type="radio" value="3"> Master 
        </div>
        <div style="text-align: center; margin-top: 30px">
          <button id="submitLevel" style="font-size: 16px">Submit</button>
          <button id="backLevel" style="font-size: 16px">Back</button>
          <button id="cancelSetLevel" style="font-size: 16px; display: none">Cancel</button><br/>
        </div>
      </div>
    </div>

    <div id="variableBG" class="modalbg">
      <div class="modal">
        <h3 style="text-align: center">Choose a new variable name</h3>
        <p>Variables currently in use:</p>
        <div id="variableList"></div>
        <p>New variable:</p>
        <input type="text" id="newvar" style="width: 100%"/>
        <div style="text-align: center; margin-top: 30px">
          <button id="submitVariable" style="font-size: 16px">Submit</button><br/>
        </div>
      </div>
    </div>

    <div id="ascribeBG" class="modalbg">
      <div class="modal">
        <h3 style="text-align: center">Ascribe a wire</h3>
        <p>Ascribe this wire to the following:</p>
        <input type="text" id="ascribe" style="width: 100%"/>
        <div style="text-align: center; margin-top: 30px">
          <button id="submitAscribe" style="font-size: 16px">Submit</button><br/>
        </div>
      </div>
    </div>

    <div id="aboutBG" class="modalbg">
      <div class="modal" style="width: 1000px; height: 800px; background-color: #cccccc">
        <h1 style="text-align: center">Welcome to Narvi!</h1>
        <div style="height: 650px; overflow-y: scroll; background-color: #ffffff; padding: 10px">
          <h2>What is Narvi?</h2>
          <p class="about">
            Narvi is a game where you prove abstract theorems in classical predicate logic by connecting boxes with wires.
            It's a fun collection of puzzles, and also an educational tool for learning to write proofs.
            There are over a hundred levels, divided into four "worlds" with several stages each, and four difficulty settings.
            There is no requirement that you do the levels in order; you can skip around, but when learning I recommend you proceed mostly in order, starting with the easier difficulty settings.
            You can also create custom levels.
          </p>
          <h2>How do the graphs work?</h2>
          <p class="about">
            In each level you have some number (perhaps zero) of "assumptions" or "givens" that appear in boxes on the left, and one desired "conclusion" appearing in a box on the right.
            Your goal is to connect the assumptions to the conclusion: logic flows from left to right.
          </p>
          <p class="about">
            You can add new boxes to the graph by dragging and dropping them from the "palette" bar on the left; more options will be added to the palette as you progress through the levels.
            Each box represents a "proof rule", and has some number of "output ports" on the right and "input ports" on the left.
            You can drag a connection from any output port to any input port, as long as they "carry" the same statement or value.
            Wires carrying "values" rather than "truth" are colored blue.
            Some boxes also give you "local assumptions" that act like output ports, but can only be used to prove the corresponding "subgoal" input port; these are matched visually with "brackets".
          </p>
          <p class="about">
            For the proof to be correct, every input port must have something coming into it, and all wires must connect ports carrying the same statement or value.
            (Not every output port needs to be used, but usually most will be.)
            When your proof is correct, the conclusion will turn green, as will that level in the level-selection dialog, with one to four stars awarded according to the difficulty setting.
            If you make a mistake, you can remove boxes and wires by clicking on the red "X" that appears when you hover over them.
          </p>
          <h2>What do the difficulty levels mean?</h2>
          <p class="about">
            At Novice difficulty (‚òÖ‚òÜ‚òÜ‚òÜ), all unconnected ports are labeled with the statement or value they carry (red for input ports, which are missing something to connect to them); all wires are labeled with the statement or value they carry; and incorrectly connected wires are colored red.
            A proof novice benefits from the most possible guidance when learning to write proofs.
          </p>
          <p class="about">
            At Adept difficulty (‚òÖ‚òÖ‚òÜ‚òÜ), wires are still labeled and colored once they are connected, but ports are not labeled.
            A proof adept can tell, given the labels on some wires are connected to a proof rule box, what statements must appear on the other wires.
            But since correctly connected wires are labeled, it is sufficient to apply this skill "locally" at each proof rule to decide on the next rules to use.
          </p>
          <p class="about">
            At Expert difficulty (‚òÖ‚òÖ‚òÖ‚òÜ), wires are not labeled either.
            A proof expert can carry the "global" proof in their head, remembering (or calculating, if necessary) what the labels must be on each wire.
            (For larger proofs arising in mathematical practice, this is unreasonable even for experts; but for the small proofs in Narvi it is feasible, and it's good to practice holding at least part of a proof in your head that's larger than a single rule.)
            However, incorrectly connected wires are still colored red, so you get immediate feedback about whether your memory or calculation was correct; and if not, where it went wrong.
          </p>
          <p class="about">
            At Master difficulty (‚òÖ‚òÖ‚òÖ‚òÖ), incorrectly connected wires are not even colored red any more: the only feedback you get is whether the conclusion turns green!
            A proof master can not only carry a substantial proof in their head; if they make a mistake, they can work out for themselves where the mistake is and fix it.
            (A word to the wise is enough.)
          </p>
          <h2>Where do these graphs come from?</h2>
          <p class="about">
            Many people have represented proofs graphically, starting with Charles Sanders Peirce, one of the inventors of predicate logic.
            More recently, the physicist Roger Penrose introduced string diagrams for tensors, mathematicians such as Andre Joyal and Ross Street formalized them to describe monoidal categories, and the logician Jean-Yves Girard introduced proof nets for linear logic.
          </p>
          <p class="about">
            The specific style of graphical proofs used by Narvi is based heavily on the graphs used by <a href="https://incredible.pm/">The Incredible Proof Machine</a> by Joachim Breitner, which is essentially a graphical representation of Gentzen-style <a href="https://en.wikipedia.org/wiki/Natural_deduction">natural deduction</a>.
            The Incredible Proof Machine is, well, incredible!
            In particular, relative to other graphical languages, it introduced "expandable brackets" for local assumptions.
            Although perhaps obvious in hindsight (they correspond to "discharged assumptions" in Gentzen's trees), I believe these are a big improvement over anything previously available, at least for informal and pedagogical purposes.
            Narvi borrows not only these expandable brackets, but other aspects of the look and feel of The Incredible Proof Machine.
          </p>
          <p class="about">
            The main enhancement added by Narvi over what The Incredible Proof Machine can do is <i>value-carrying wires</i> for predicate logic.
            The Incredible Proof Machine does support predicate logic, but the elements are managed only by unification rather than visually with wires (and also its rules are single-sorted and don't support empty domains).
            Narvi also includes some other features that could probably also be added to The Incredible Proof Machine with less work, such as if-and-only-if blocks and classical proof by contradiction.
            In addition, although Narvi is currently restricted to proofs about abstract sets, propositions, and predicates like The Incredible Proof Machine, since its underlying logic is a full-spectrum dependent type theory, it should be possible to extend it to proofs using algebra and mathematical induction.
          </p>
          <p class="about">
            On the other hand, the underlying logic of the The Incredible Proof Machine is more configurable than Narvi's.
            For instance, in addition to predicate logic, it supports Hilbert systems and NAND calculus.
            Moreover, The Incredible Proof Machine has other nice features that Narvi currently lacks: it saves your proof for each level when you switch to another one, and its unification algorithm can infer labels for more wires and ports in an incomplete proof than Narvi's (in fact, Narvi doesn't currently use unification <i>per se</i> at all, only bidirectional typechecking).
            If you like Narvi, you should check out <a href="https://incredible.pm/">The Incredible Proof Machine</a> too!
          </p>
          <h2>What's under the hood?</h2>
          <p class="about">
            The underlying proof-checker of Narvi is <a href="https://github.com/mikeshulman/narya">Narya</a>.
            Narya is an experimental proof assistant for higher-dimensional dependent type theory such as higher observational type theory (HOTT) and internally parametric type theories.
            Narvi doesn't currently use very much of the power of Narya, but in principle it could be extended to be a full-fledged graphical proof assistant for dependent type theory using the same core.
          </p>
          <p class="about">
            Narya is written in OCaml, which through the magic of <tt>js_of_ocaml</tt> is compiled to run in your browser underneath Narvi.
            If you'd like to try Narya directly, its ordinary interactive mode is also available in your browser as <a href="https://mikeshulman.github.io/jsnarya/">jsNarya</a>.
            If Narvi and jsNarya whet your appetite, you can download the full Narya proof assistant to run locally on your computer from its <a href="https://github.com/mikeshulman/narya">github page</a>.
          </p>
          <h2>Narya? Narvi?</h2>
          <p class="about">
            Narya is the third elven-ring in J.R.R. Tolkien's Legendarium: the ring of fire (which is <i>HOT(T)</i>), that was given by C&iacute;rdan the Shipwright to Gandalf when he arrived in Middle-Earth.
            Narvi was a dwarven craftsman who, together with Celebrimbor, made the Doors of Durin at the West-gate of Moria with their intricate <i>pictures</i>.
          </p>
          <h2>Who wrote all this?</h2>
          <p class="about">
            Mike Shulman, a mathematician at the University of San Diego.
            <a href="https://home.sandiego.edu/~shulman/">Here's</a> my web page.
            Send me your questions, suggestions, complaints, and other thoughts!
            I look forward to hearing from you.
          </p>
        </div>
        <div style="text-align: center; margin-top: 30px">
          <button id="doneAbout" style="font-size: 16px">Close</button><br/>
        </div>
      </div>
    </div>

    <script src="bundle.js"></script>
</body>
</html>
