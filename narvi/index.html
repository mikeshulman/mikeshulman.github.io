<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Narvi</title>
    <link rel="stylesheet" href="styles.css">
    <script src=" https://cdn.jsdelivr.net/npm/interactjs@1.10.27/dist/interact.min.js "></script>
    <script src="narvi.bc.js"></script>
</head>
<body>
    <div id="paletteBar">
      <div id="palette">
        <div class="basic logical intro rule" id="andI" data-rule="andI">‚àß</div>
        <div class="basic logical elim rule" id="andE" data-rule="andE">‚àß</div>
        <div class="basic logical intro rule" id="orI1" data-rule="orI1">‚à®<sub>L</sub></div>
        <div class="basic logical intro rule" id="orI2" data-rule="orI2">‚à®<sub>R</sub></div>
        <div class="container rule" id="orE" data-rule="orE">
          <div class="mid bar"></div>
          <div class="doubleleft assumption"><div class="subgoallabel">‚à®</div></div>
          <div class="doubleright subgoal"></div>
          <div class="mid midleft"></div>
          <div class="mid midright"></div>
        </div>
        <div class="container rule" id="impI" data-rule="impI">
          <div class="bottom bar"></div>
          <div class="singleleft assumption"></div>
          <div class="singleright subgoal"><div class="subgoallabel">‚áí</div></div>
          <div class="bottomleft"></div>
          <div class="bottomright"></div>
        </div>
        <div class="basic logical elim rule" id="impE" data-rule="impE">‚áí</div>
        <div class="container rule" id="iffI" data-rule="iffI">
          <div class="mid bar"></div>
          <div class="doubleleft assumption"></div>
          <div class="doubleright subgoal"><div class="subgoallabel">‚áî</div></div>
          <div class="mid midleft"></div>
          <div class="mid midright"></div>
        </div>
        <div class="basic logical elim rule" id="iffE1" data-rule="iffE1">‚áî<sub>L‚ÜíR</sub></div>
        <div class="basic logical elim rule" id="iffE2" data-rule="iffE2">‚áî<sub>R‚ÜíL</sub></div>
        <div class="basic logical intro rule" id="exI" data-rule="exI"> ‚àÉ</div>
        <div class="basic logical elim rule" id="exE" data-rule="exE">‚àÉ</div>
        <div class="container rule" id="allI" data-rule="allI">
          <div class="bottom bar"></div>
          <div class="singleleft assumption"></div>
          <div class="singleright subgoal"><div class="subgoallabel">‚àÄ</div></div>
          <div class="bottomleft"></div>
          <div class="bottomright"></div>
        </div>
        <div class="basic logical elim rule" id="allE" data-rule="allE">‚àÄ</div>
        <div class="basic logical elim rule" id="negE" data-rule="negE">¬¨</div>
        <div class="container rule" id="negI" data-rule="negI">
          <div class="bottom bar"></div>
          <div class="singleleft assumption"></div>
          <div class="singleright subgoal"><div class="subgoallabel">¬¨</div></div>
          <div class="bottomleft"></div>
          <div class="bottomright"></div>
        </div>
        <div class="container rule" id="negnegI" data-rule="negnegI">
          <div class="bottom bar"></div>
          <div class="singleleft assumption" style="width:27px"><div class="assumptionlabel">¬¨</div></div>
          <div class="singleright subgoal"></div>
          <div class="bottomleft"></div>
          <div class="bottomright"></div>
        </div>
        <div class="basic logical rule" style="text-align: left" id="botE" data-rule="botE">‚ä•</div>
        <div class="basic logical rule" style="text-align: right" id="topI" data-rule="topI">‚ä§</div>
      </div>
        <!-- <div class="basic logical rule" style="text-align: center" id="asc" data-rule="asc">üè∑</div> -->
      <div style="height: 60px; display: flex; align-items: end" id="buttons"><button id="selectLevel">Select Level</button></div>
    </div>
    <div id="diagram"></div>

    <div id="currentLevelAndDifficulty">
      <div id="currentLevel"></div>
      <div id="currentDifficulty"></div>
    </div>

    <div id="levelChooseBG" class="modalbg">
      <div class="modal" id="levelChooseModal">
        <div style="text-align: center; font-size: 24px; display: grid; grid-template-columns: 1fr 20px 500px 20px 1fr; margin-bottom: 20px">
          <div></div>
          <div id="backWorld" style="cursor: pointer">‚óÄ</div>
          <div id="worldName">Select a level</div>
          <div id="forwardWorld" style="cursor: pointer">‚ñ∂</div>
          <div></div>
        </div>
        <p id="chooseLevelWarning" style="visibility: hidden; text-align: center">(Choosing a new level clears any existing proof)</p>
        <div id="worlds">
        </div>
        <div id="chooseLevelButtons">
          <div style="text-align: center; margin-top: 30px; display: flex">
            <div id="noviceRadio" class="difficultyRadio"><div id="noviceBox">‚òê</div>&nbsp;Novice</div>
            <div id="adeptRadio" class="difficultyRadio"><div id="adeptBox">‚òê</div>&nbsp;Adept</div>
            <div id="masterRadio" class="difficultyRadio"><div id="masterBox">‚òê</div>&nbsp;Master</div>
          </div>
          <div style="text-align: center; margin-top: 30px">
            <button id="cancelChooseLevel" style="font-size: 16px; display: none">Cancel</button>
            <button id="clearHistory" style="font-size: 16px">Clear History</button>
            <button id="about" style="font-size: 16px">About</button>
            <br/>
          </div>
        </div>
      </div>
    </div>

    <div id="levelSelectBG" class="modalbg">
      <div class="modal">
        <h3 style="text-align: center">What do you want to prove?</h3>
        <span id="setLevelWarning" style="display: none">(Choosing a new level clears any existing proof)</span>
        <p>Parameters, as <tt>name : type</tt>, one per line:</p>
        <textarea id="parameters" style="width: 100%" rows="3"></textarea>
        <div id="paramPalette"></div>
        <p>Variables, as <tt>name : type</tt>, one per line:</p>
        <textarea id="variables" style="width: 100%" rows="3"></textarea>
        <div id="varPalette"></div>
        <p>Hypotheses, types only (i.e. propositions), one per line:</p>
        <textarea id="hypotheses" style="width: 100%" rows="3"></textarea>
        <div id="hypPalette"></div>
        <p>Conclusion:</p>
        <input type="text" id="conclusion" style="width: 100%; font-family: monospace"/>
        <div id="conclPalette"></div>
        <div style="text-align: center; margin-top: 30px">
          <input name="customDifficulty" type="radio" value="0" checked="1"> Novice &nbsp;&nbsp;
          <input name="customDifficulty" type="radio" value="1"> Adept &nbsp;&nbsp;
          <input name="customDifficulty" type="radio" value="2"> Master
        </div>
        <div style="text-align: center; margin-top: 30px">
          <button id="submitLevel" style="font-size: 16px">Submit</button>
          <button id="backLevel" style="font-size: 16px">Back</button>
          <button id="cancelSetLevel" style="font-size: 16px; display: none">Cancel</button><br/>
        </div>
      </div>
    </div>

    <div id="variableBG" class="modalbg">
      <div class="modal">
        <h3 style="text-align: center">Choose a new variable name</h3>
        <p>Variables currently in use:</p>
        <div id="variableList"></div>
        <p>New variable:</p>
        <input type="text" id="newvar" style="width: 100%"/>
        <div style="text-align: center; margin-top: 30px">
          <button id="submitVariable" style="font-size: 16px">Submit</button>
          <button id="cancelVariable" style="font-size: 16px">Cancel</button><br/>
        </div>
      </div>
    </div>

    <div id="ascribeBG" class="modalbg">
      <div class="modal">
        <h3 style="text-align: center">Ascribe a wire</h3>
        <p>Ascribe this wire to the following:</p>
        <input type="text" id="ascribe" style="width: 100%"/>
        <div id="ascPalette"></div>
        <div style="text-align: center; margin-top: 30px">
          <button id="submitAscribe" style="font-size: 16px">Submit</button><br/>
        </div>
      </div>
    </div>

    <div id="wireBG" class="modalbg">
      <div class="modal">
        <h3 style="text-align: center">Label this wire</h3>
        <p>Label this wire with the following set or proposition:</p>
        <input type="text" id="wire" style="width: 100%"/>
        <div id="wirePalette"></div>
        <div style="text-align: center; margin-top: 30px">
          <button id="submitWire" style="font-size: 16px">Submit</button><br/>
        </div>
      </div>
    </div>

    <div id="aboutBG" class="modalbg">
      <div class="modal" style="width: 1000px; height: 800px; background-color: #cccccc">
        <h1 style="text-align: center">Welcome to Narvi!</h1>
        <div style="height: 650px; overflow-y: scroll; background-color: #ffffff; padding: 10px">
          <h2>What is Narvi?</h2>
          <p class="about">
            Narvi is a game where you prove abstract theorems in classical predicate logic by connecting boxes with wires.
            It's a fun collection of puzzles, and also an educational tool for learning to write proofs.
            There are over a hundred levels, divided into four "worlds" with several stages each, and three difficulty settings.
            There is no requirement that you do the levels in order; you can skip around, but when learning I recommend you proceed mostly in order (see below for advice on choosing the difficulty).
            You can also create and solve custom levels.
          </p>
          <h2>How do the graphs work?</h2>
          <p class="about">
            In each level you have some number (perhaps zero) of "assumptions" or "givens" that appear in boxes on the left, and one desired "conclusion" appearing in a box on the right.
            Your goal is to connect the assumptions to the conclusion: logic flows from left to right.
          </p>
          <p class="about">
            You can add new boxes to the graph by dragging and dropping them from the "palette" bar on the left; more options will be added to the palette as you progress through the levels.
            Each box represents a "proof rule", and has some number of "input ports" on the left and "output ports" on the right.
            You can drag a connection from any output port to any input port, and it will be valid as long as they "carry" the same statement or value.
            Wires carrying "values" rather than "truth" are colored blue.
            Some boxes also give you "local assumptions" that act like output ports, but can only be used to prove the corresponding "subgoal" input port; these are matched visually with "brackets".
          </p>
          <p class="about">
            For the proof to be correct, every input port must have something coming into it, and all wires must connect ports carrying the same statement or value.
            (Not every output port needs to be used, but usually most will be.)
            When your proof is correct, the conclusion and background will turn a color (according to the difficulty level), as will that level in the level-selection dialog, with one to three stars awarded according to the difficulty setting.
            If you make a mistake, you can remove boxes and wires by clicking on the red "X" that appears when you hover over them.
          </p>
          <h2>What do the difficulty settings mean?</h2>
          <p class="about">
            At Novice difficulty (<span id="aboutNovice" style="padding:1px">‚òÖ‚òÜ‚òÜ</span>), all unconnected ports are labeled with the statement or value they carry (red for input ports, which are missing something to connect to them).
            In addition, all wires are labeled with the statement or value they carry, and incorrectly connected wires are colored red.
            At any given point during the construction of a proof, the labeled output ports can be thought of as "givens" (known or assumed facts), and the red-labeled input ports can be thought of as "goals" (statements to prove).
            <i>A proof novice can choose the rule to apply next, guided by the logical structure of the givens and the goals.</i>
          </p>
          <p class="about">
            At Adept difficulty (<span id="aboutAdept" style="padding:1px">‚òÖ‚òÖ‚òÜ</span>), ports are not labeled, and most wires are not labeled automatically.
            Instead, you are prompted for a label for each wire.
            (The exceptions are wires connected directly to a hypothesis or the conclusion, since it is obvious what those should be labeled, and wires that carry values.)
            Wires with incorrect labels, or that are incorrectly connected, are colored red, and both prevent the proof from being marked correct.
            In particular, even if your wires would be a correct proof in Novice mode, it is rejected if you labeled them incorrectly.
            <i>A proof adept knows how each applied rule affects the current givens and goals.</i>
          </p>
          <p class="about">
            At Master difficulty (<span id="aboutMaster" style="padding:1px">‚òÖ‚òÖ‚òÖ</span>), you are still required to label all the wires yourself (with the same exceptions), but incorrectly connected or labeled wires are not colored red any more.
            The only information you get about the correctness of the proof (including your labels on the wires) is whether the conclusion turns purple!
            <i>A proof master can plan and execute an entire proof alone, and find and fix their own mistakes.</i>
          </p>
          <p class="about">
            I recommend that you work up in difficulty setting "one world behind" your most advanced levels.
            For instance, start by completing Proposition World at Novice setting.
            Then complete Advanced Proposition World at Novice setting.  Then go back and re-do Proposition World at Adept setting.
            Next, work on Quantifier World at Novice setting, Advanced Proposition World at Adept setting, and Proposition World at Master setting, and so on.
            By inserting a delay before you go back to re-do each level at a higher difficulty, you will reinforce your learning and make the challenge more meaningful.
            Similarly, when you are working through a given world at a higher difficulty setting, it would be easy to "cheat" by doing each level again at Novice setting and then copying the proof and wire labels from your short-term memory at the higher difficulty, but you won't learn as much that way.
          </p>
          <p class="about">
            It's worth noting that whether a given wire is colored red as "incorrect" in Novice and Adept modes can depend not only on that wire and its label, but on the other wires in the diagram.
            A wire in an incomplete proof may be colored black at first, but become red when <i>another</i> wire is added, since the second wire gives additional information about what must be carried by the first wire.
          </p>
          <p class="about">
            Somewhat more surprisingly, the opposite can also happen: a wire can be colored red at first but become black when another wire is added.
            This generally happens if you connect a "proposition" wire to a quantifier rule (‚àÄ or ‚àÉ) without first connecting the corresponding "value" wire, since until Narvi knows what the value is, it can't tell that the proposition wire is correct.
            This is arguably a bug, since in other contexts "not yet known to be incorrect" wires are colored black rather than red, but the prospects of fixing it in the near future are slim, due to Narya's current lack of a full unification algorithm.
            Just make a habit of always connecting the value (blue) wires first.
          </p>
          <h2>Where do these graphs come from?</h2>
          <p class="about">
            Many people have represented proofs graphically, starting with Charles Sanders Peirce, one of the inventors of predicate logic.
            More recently, the physicist Roger Penrose introduced string diagrams for tensors, mathematicians such as Andre Joyal and Ross Street formalized them to describe monoidal categories, and the logician Jean-Yves Girard introduced proof nets for linear logic.
          </p>
          <p class="about">
            The specific style of graphical proofs used by Narvi is based heavily on the graphs used by <a href="https://incredible.pm/">The Incredible Proof Machine</a> by Joachim Breitner, which is essentially a graphical representation of Gentzen-style <a href="https://en.wikipedia.org/wiki/Natural_deduction">natural deduction</a>.
            The Incredible Proof Machine is, well, incredible!
            In particular, relative to other graphical languages, it introduced "expandable brackets" for local assumptions.
            Although perhaps obvious in hindsight (they correspond to "discharged assumptions" in Gentzen's trees), I believe these are a big improvement over anything previously available, at least for informal and pedagogical purposes.
            Narvi borrows not only these expandable brackets, but other aspects of the look and feel of The Incredible Proof Machine.
          </p>
          <p class="about">
            The main enhancement added by Narvi over what The Incredible Proof Machine can do is <i>value-carrying wires</i> for predicate logic.
            The Incredible Proof Machine does support predicate logic, but the elements are managed only by unification rather than visually with wires (and also its rules are single-sorted and don't support empty domains).
            Narvi also includes some other features that could probably also be added to The Incredible Proof Machine with less work, such as if-and-only-if blocks and classical proof by contradiction, and some additional pedagogical and gamification features such as Adept and Master difficulty levels.
            In addition, although Narvi is currently restricted to proofs about abstract sets, propositions, and predicates like The Incredible Proof Machine, since its underlying logic is a full-spectrum dependent type theory, it should be possible to extend it to proofs using algebra and mathematical induction.
          </p>
          <p class="about">
            On the other hand, the underlying logic of the The Incredible Proof Machine is more configurable than Narvi's.
            For instance, in addition to predicate logic, it supports Hilbert systems and NAND calculus.
            Moreover, The Incredible Proof Machine has other nice features that Narvi currently lacks: it saves your proof for each level when you switch to another one, and its unification algorithm can infer labels for more wires and ports in an incomplete proof than Narvi's (in fact, Narvi doesn't currently use unification <i>per se</i> at all, only bidirectional typechecking).
            If you like Narvi, you should check out <a href="https://incredible.pm/">The Incredible Proof Machine</a> too!
          </p>
          <h2>What's under the hood?</h2>
          <p class="about">
            The underlying proof-checker of Narvi is <a href="https://github.com/mikeshulman/narya">Narya</a>.
            Narya is an experimental proof assistant for higher-dimensional dependent type theory such as higher observational type theory (HOTT) and internally parametric type theories.
            Narvi doesn't currently use very much of the power of Narya, but in principle it could be extended to be a full-fledged graphical proof assistant for dependent type theory using the same core.
          </p>
          <p class="about">
            Narya is written in OCaml, which through the magic of <tt>js_of_ocaml</tt> is compiled to run in your browser underneath Narvi.
            If you'd like to try Narya directly, its ordinary interactive mode is also available in your browser as <a href="https://mikeshulman.github.io/jsnarya/">jsNarya</a>.
            If Narvi and jsNarya whet your appetite, you can download the full Narya proof assistant to run locally on your computer from its <a href="https://github.com/mikeshulman/narya">github page</a>.
          </p>
          <h2>Narya? Narvi?</h2>
          <p class="about">
            Narya is the third elven-ring in J.R.R. Tolkien's Legendarium: the ring of fire (which is <i>HOT(T)</i>), that was given by C&iacute;rdan the Shipwright to Gandalf when he arrived in Middle-Earth.
            Narvi was a dwarven craftsman who, together with Celebrimbor, made the Doors of Durin at the West-gate of Moria with their intricate <i>pictures</i>.
          </p>
          <h2>Who wrote all this?</h2>
          <p class="about">
            Mike Shulman, a mathematician at the University of San Diego.
            <a href="https://home.sandiego.edu/~shulman/">Here's</a> my web page.
            Send me your questions, suggestions, complaints, and other thoughts!
            I look forward to hearing from you.
          </p>
        </div>
        <div style="text-align: center; margin-top: 30px">
          <button id="doneAbout" style="font-size: 16px">Close</button><br/>
        </div>
      </div>
    </div>

    <script src="bundle.js"></script>
</body>
</html>
